---
title: 发布/订阅
id: pub-sub-concepts
category: concepts
---

Pulsar 基于[发布-订阅](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) （通常缩写为 pub-sub）。在这种模式中，[生产者](#producers)向[主题](#topics)发布消息。[消费者](#消费者)[订阅](#订阅)这些主题，处理收到的消息，并在处理完成后发送确认。

创建订阅后，Pulsar 会保留所有消息，即使消费者已经断开连接，这些消息仍会保留。只有在消费者确认消息成功处理后，才会将消息丢弃。

# 租户

Pulsar 是从头开始创建的多租户系统。为支持多租户，Pulsar 提出了“租户”的概念。租户可以分布在多个集群中，并且每个租户都具有自己的身份验证和授权方案。租户也是可以管理存储配额、消息  TTL 和隔离策略的管理单元。

如需了解关于创建租户的细节，参见[使用租户](/user-guides/admin/work-with-tenants.md)。

# 命名空间

命名空间代表租户内的管理单元。在命名空间所设置的配置策略适用于在该命名空间中创建的所有主题。你可以使用 StreamNative 控制器、REST API 或 pulsar-admin CLI（命令行工具）为租户创建多个命名空间。

如需了解关于创建命名空间的细节，参见[使用命名空间](/user-guides/admin/work-with-namespaces.md)。

## 权限

Pulsar 在命名空间级别（租户和集群内）对权限进行管理。可以为特定的用户授予操作列表权限，如`消费`和`生产`。此外也可以撤销特定用户的权限。撤销后，这些用户将不能访问指定的命名空间。

## Backlog quota

Backlog 是指由 bookie 储存的、关于某一主题的未确认消息的集合。在这些未确认的消息被处理和确认前，Pulsar 都会将这些消息储存在 backlog 中。
可以使用 backlog quota 控制命名空间水平所允许的 backlog 的大小。对于 backlog quota，可设置如下项目：

- 命名空间中，每个主题可允许的阈值大小
- 保留策略：决定了当超过阈值时 broker 将采取的行动。

下表列出可用的保留策略。
| 策略 | 行动 |
| --- | --- |
| `producer_request_hold` | Broker 暂停、但不保留生产者的请求有效负载。 |
| `producer_exception` | Broker 从客户端断开，抛出异常。 |
| `consumer_backlog_eviction` | Broker 开始从 backlog 丢弃积压消息。 |
## Bundle

对于赋值来说，命名空间被分片成 bundle 的列表，每个 bundle 包括命名空间整体哈希范围的一部分。Bundle 是属于同一命名空间的主题的虚拟组。一个命名空间束范围在两个 32 位哈希值之间，例如从 0x00000000 到 0xffffffff。默认情况下，每个命名空间支持 4 个 bundle。

由于 bundle 中主题的负载可能会随着时间而改变，broker 可以将一个 bundle 拆分成两个 bundle。随后新的较小的 bundle 被重新分配给不同的 broker。默认情况下，新拆分的 bundle 会被立即卸载给其他 broker 来实现流量分配。

## 调度率

调度率指命名空间的主题每秒派发的消息数量。要限制调度率，可调节每秒消息数（`msg-dispatch-rate`）或每秒消息字节数（`byte-dispatch-rate`）。调度率的单位是秒，可用 `dispatch-rate-period` 配置。默认情况下，`msg-dispatch-rate` 和 `byte-dispatch-rate` 都设置为 -1，表明禁用限流。

# 主题

和发布-订阅系统一样，Pulsar 的主题是消息从生产者传递给消费者的有命名的通道。Pulsar 支持持久化和非持久化主题。默认情况下，如果不指定主题类型，就会创建一个持久化主题。对于持久化主题，所有的消息都持久地保存在磁盘上（如果没有独立的 broker，消息会持久地保存在多个磁盘上）。非持久性主题的数据不会持久地保存在存储磁盘上。

主题名称是 URL，具有明确的结构：

```http
{persistent|non-persistent}://tenant/namespace/topic
```

主题名组成 | 描述 
:--------------------|:-----------
`persistent` / `non-persistent` | 标识主题类型。Pulsar 支持持久化和[非持久化](#非持久化主题)主题。默认情况下，如果你不指定主题类型，就会创建一个持久化主题。对于持久化主题，所有的消息都持久地保存在磁盘上（如果没有独立的 broker，消息会持久地保存在多个磁盘上）。而非持久性主题的数据不会持久地保存在存储 disk 上。 
`tenant`             | 实例中的主题租户。租户是 Pulsar 多租户的不可缺的组成部分，分布在各个集群中。 
`namespace`          | 主题的管理单元，作为相关主题的分组机制。大多数主题配置是在[命名空间](#命名空间)级别进行的。每个租户有一个或多个命名空间。 
`topic`              | 名称的最后部分。`topic` 的名称在 Pulsar 实例中没有特殊含义。 

无需在 Pulsar 中特别创建主题。如果客户端向尚不存在的主题写入消息、或者从不存在的主题接收消息，Pulsar 会在[主题名称](#主题)提供的命名空间下自动创建该主题。如果在客户端创建主题时没有指定租户或命名空间，那么该主题将在默认的租户和命名空间中创建。也可以在指定的租户和命名空间中创建一个主题，例如 `persistent://my-tenant/my-namespace/my-topics`。`persistent://my-tenant/my-namespace/my-topic `，指 `my-topic` 主题是在 `my-tenant` 租户的 `my-namespace` 命名空间中创建的。

## 非持久化主题

非持久化主题是指消息从未在磁盘上持久化、只是存放在内存中的主题。当使用非持久化传递时，弃用 Pulsar broker 或断开订阅者与主题的连接，非持久化主题的所有传输消息将丢失。在非持久化主题中，broker 会立即将消息传递给所有连接的订阅者，而不会在 BookKeeper 中持久保存。 

### 性能

因为 broker 不会持久化消息，非持久化消息传递通常比持久化消息传递更快，一旦该消息被传递给连接的 broker，就会立即向生产者发送 acks。因此对于生产者，非持久化主题的发布延迟相对较短。

## 分区主题

普通主题仅仅是由单一 broker 提供的，限制了该主题的最大通量。分区主题是特殊类型的主题，由多个 broker 处理，因此允许更大的通量。

分区主题实际上是由 N 个内部主题实现的，其中 N 是分区的数量。当向一个分区主题发布消息时，每条消息会途径多个 broker 中的某个 broker。Broker 间如何分配分区则是由 Pulsar 自动处理。

### 路由模式

发布到分区主题时，你必须指定一个*路由模式*。路由模式决定了每个消息应该发布到哪个分区，也就是哪个内部主题。

模式     | 描述 
:--------|:------------
`RoundRobinPartition` | 如果没有提供 key，生产者将在所有分区中以 round-robin 方式发布消息，以达到最大通量。需要注意的是，round-robin 不是按单个消息进行，而是将其批处理延迟边界设置为相同，以确保批处理的有效性。而如果在消息上指定了 key，分区生产者将对 key 进行哈希运算，并将消息分配得到一个特定的分区。此模式为默认模式。 
`SinglePartition`     | 如果没有提供 key，生产者将随机挑选单一分区，将所有消息发布到这个分区。如果消息指定了 key，则分区生产者将对 key 进行哈希运算，将消息分配到特定分区。 
`CustomPartition`     | 执行自定义消息路径来确定特定消息去往的分区。 

### 排序保证

消息的排序与路径模式和消息的 key 相关。通常用户会希望有 Per-Key-partition 保证排序。

如果消息上附有 key，当使用 `SinglePartition` 或 `RoundRobinPartition` 模式时，消息将根据[散列 scheme](#散列-scheme)，被分配到对应的分区。 

 排序保证          | 描述 | 路径模式和 key                                               
:------------------|:------------|:------------
Per-key-partition  | 具有相同 key 的消息将按顺序排列，并被发放到相同的分区。 | 使用 `SinglePartition` 或 `RoundRobinPartition` 模式，且每个消息都有 key。 
Per-producer       | 所有来自同一个生产者的消息将按顺序排列。                | 使用 `SinglePartition` 模式，且并未对每个消息都提供 key。 

### 散列 scheme

散列 scheme 是一种枚举，表示在选择用于特定消息的分区时可用的标准散列函数集。

有2种类型的标准散列函数可用：`JavaStringHash `和 `Murmur3_32Hash`。
对生产者来说，默认的散列函数是  `JavaStringHash`。
注意：生产者可能来自不同语言客户端时，`JavaStringHash` 是不起作用的。建议使用  `Murmur3_32Hash`。

## 死信主题

当有些消息不能被消费者成功处理时，通过死信主题，消费者可以去消费新的消息。在这个机制中，未能被消费的消息将被储存到一个独立的主题中，即死信主题。你可决定如何处理死信主题中的消息。

死信主题依赖消息的再传递。消息重新投递的原因可以是：[确认超时](#acknowledgement-timeout)或[否定确认（ negative acknowledgement）](#negative-acknowledgement)。如果要对消息使用否定确认，需确保在确认超时前进行否定确认。

> **注**    
> 当前在 [Shared](#shared) 和 [Key_Shared](#key_shared) 订阅模式下可启用死信主题。

## 重试发信主题

对于很多线上业务系统来说，业务逻辑处理异常，导致消息被重新消费。为了配置重新消费失败消息的延迟时间，可以配置生产者向业务主题和重试发信主题发送消息，并在消费端启动自动重测。当在消费者上启用自动重试时，如果消息没有被消费，则会被保存在重试发信主题中，因此消费者在指定的延迟时间后，会自动消费重试发信主题中的失败消息。

## Schema

Pulsar 具有内置 schema 注册表，客户能够在每个主题的基础上上传数据 schema。这些 schema 决定了哪些数据类型可被认定为对该主题有效。Pulsar schema 使你能够在构建和处理消息时使用特定语言的数据类型，简单的如 `string` ，也有更复杂的特定应用类型。

# 消息

消息是 Pulsar 的基本单位。如下表格列出消息的组成部分。 

组成部分 | 描述 
:---------|:-------
值/数据有效负载 | 消息所携带的数据。尽管消息数据也可以符合数据 schema，但所有 Pulsar 消息都包含原始字节。 
Key | 可选，可用于标记消息，对于主题压缩等有帮助。                 
属性 | 用户定义属性的 key 和赋值的关系图。                          
 生产者名            | 产生消息的生产者的名字。如果没有指定生产者的名字，则会使用默认名。 
序列 ID | 每个 Pulsar 消息都属于相关主题的有序序列。消息的序列 ID 是它在该序列中的顺序。 
 发布时间            | 由生产者自动生成的时间戳。时间戳是由生产者自动应用的。 
 事件时间            | 应用程序附加在消息上的可选时间戳。例如，应用程序会在消息被处理时附加一个时间戳。如果没有对事件时间进行任何设置，其值为 `0`。 
TypedMessageBuilder | 用来构建消息。可以通过  `TypedMessageBuilder` 设置消息属性，如消息的 key 和赋值等。 </br> 设置 `TypedMessageBuilder` 时，将 key 设置为字符串。如果把 key 设置为其他类型，如 AVRO 对象，key 就会以字节形式发送，这样就很难把 AVRO 对象发回给消费者。 

## 消息压缩

在运输过程中，可对生产商发布的消息进行压缩。Pulsar 目前支持如下压缩类型： 

* [LZ4](https://github.com/lz4/lz4)
* [ZLIB](https://zlib.net/)
* [ZSTD](https://facebook.github.io/zstd/)
* [SNAPPY](https://google.github.io/snappy/)

## 消息保留和过期

默认情况下，Pulsar 的 broker 会立即删除所有已经被消费者确认的消息，而所有没有确认的消息则持续储存在消息 backlog 中。

所有消息保留和过期都是在[命名空间](#命名空间)水平管理的。下图解释了消息保留和过期的情况。

![Message retention and expiry](../../image/retention-expiry.png)

### 消息保留 

消息保留使你能够存储已经被消费者确认的消息。通过顶部显示的消息保留，适用于命名空间中所有主题的保留策略表明，即使某些消息已经被确认，也会被持久地保存在 Pulsar 中。不在保留策略范围内的已确认的消息将被删除。如果没有保留策略，*所有*已确认的消息都会被删除。 

### 消息过期

消息过期是用户为尚未被确认的消息设置一个生存时间（TTL）。

消息过期的情况下，消息显示在底部，即使这些消息没有被确认，也会因为超过了命名空间的 TTL 而被删除（例如，设置 TTL 为 5 分钟，但 10 分钟过去了消息仍未被确认）。 

## 消息去重

当一个消息被 Pulsar 持续保存一次以上时，就会出现消息重复。消息去重是 Pulsar 的一项可选的功能，每条消息只处理一次，即使该消息被接收了不止一次，也能防止不必要的消息重复。重复消息处理对应命名空间级别或主题级别处理。

下图说明禁用和打开消息去重时的情况：

![Pulsar message deduplication](../../image/message-deduplication.png)

上图显示重复消息删除功能被禁用的场景。生产者在一个主题上发布消息 1；该消息到达一个 Pulsar 代理，并被持久化到 BookKeeper。然后生产者再次发送消息 1（由于一些重试逻辑而反复发送），消息被 broker 收到并再次存储在 BookKeeper 中，由此发生消息重复。

下图情况中，生产者发布消息 1，broker 接收到该消息并持久化，至此和第一张图的情况相同。但当生产者试图再次发送该消息时，broker 知道已经接受过消息 1，便不会对该消息持久化。

### 生产者幂等 

另一种消息去重方法是确保每条消息只产生一次，这种方法通常被称为**生产者幂等**。这种方法的缺点是，它将消息去重的工作推迟到应用程序来进行。在 Pulsar 中则是 broker 层面上处理，无需修改 Pulsar 客户端代码，而只需要做管理改变。详情请见管理消息去重。

### 去重和有效一次（effectively-once）语义

消息去重使得 Pulsar 成为理想的消息传递系统，可与流处理引擎（SPE）和其他寻求提供有效一次（effectively-once）处理语义的系统一起使用。不提供自动消息去重的系统需要 SPE 或其他系统保证消息去重，这意味着要实现严格的消息排序，就需要叠加使用消息去重应用程序。而对于 Pulsar，要实现严格的排序保证无需付出任何应用层面的成本。

## 延迟消息传递

延迟消息传递使得消费者无需立即消费一条消息，而是可以稍后消费。在这个机制中，消息被存储在 BookKeeper 中，消息被发布给 broker 后，`DelayedDeliveryTracker` 在内存中维护时间索引（time->messageId），一旦超过特定的延迟时间，消息就会被传递给消费者。 

延迟消息发送只在 [Shared](#shared) 订阅模式下有效。在 [Exclusive](#exclusive) 和 [Failover](#failover) 订阅模式下，延迟的消息仍会被立即发送。

下图解释了延迟消息传递的概念：

![Delayed Message Delivery](../../image/message_delay.png)

Broker 保存消息而不做任何检查。当消费者消费消息时，如果该消息被设置为延迟，那么该消息将被添加到 `DelayedDeliveryTracker`。订阅检查将从`DelayedDeliveryTracker` 获得超时消息。 

# 生产者

生产者是向主题添加消息、并将消息发布给 Pulsar broker 的过程。 

## 发送模式

生产者向 broker 发送消息，发送可以是同步的（sync） 也可以是异步的（async）。

| 模式       | 描述 |
|:-----------|-----------|
| 同步发送 | 生产者在发送每条消息后，都会等待来自 broker 的确认。如果没有收到确认，则生产者将认为发送失败。                                                                                                                     |
| 异步发送 | 生产者会将消息放到阻塞队列中并立即返回。客户端库在后台将消息发送给 broker。如果队列已满（用户可以配置队列大小），则调用 API 时，producer 可能会立即被阻止或失败，具体取决于传递给 producer 的参数。 |

## 访问模式

对于生产者产生的主题，你可选择不同的访问模式。

| 访问模式           | 描述 |
|---|---|
|`Shared`|多个生产者可发表同一个主题。 <br><br>此为**默认**设置。|
|`Exclusive`|一个主题仅能有一个生产者。 <br><br>如果已经连接了一个生产者，则其他生产者试图在这个主题上发表时，会立即出现错误。<br><br>如弃用原来的生产者，则生产者和 broker 的网络分区断开，broker 与所选的新的生产者建立联系。|
|`WaitForExclusive`|如果已经连接了一个生产者，那么这个生产者的创建将被挂起（而不是超时），直到这个生产者获得  `Exclusive`  访问。<br><br>成功成为专有生产者后，这个生产者将被视为领导者。如果你想为应用程序实现领导者选举，则可以使用这种访问模式。|

> **注**
>
> 一旦某个应用程序出现一个生产者成功实现了 `Exclusive`  或  `WaitForExclusive` 访问模式，该应用程序的实例将成为该主题的**唯一创作者**。其他创作者对这一主题进行输出时，将立即得到错误提示，或等待获得  `Exclusive` 访问。 

# 消费者

消费者是通过订阅附加到主题上、然后接收消息的过程。

消费者向 broker 发送流许可请求以获得消息。在消费者一方有队列来接收从 broker 推送的消息。你可以用 `receiverQueueSize` 参数配置队列大小。默认值为 `1000`）。每次调用 `consumer.receive()` 时，都会从缓冲区获取到一条消息。 

## 接收模式

从 broker 收到的消息可以是同步的（ sync），也可以是异步的（async）。

| 模式     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| 同步接收 | 同步保持阻断，直到接收到消息。                               |
| 异步接收 | 异步接收会立即返回一个未来值。例如 Java [`CompletableFuture`](http://www.baeldung.com/java-completablefuture)，一旦有新的消息就会完成。 |

## 确认

当消费者成功地消费消息，消费者会向 broker 发送确认请求。这个消息将被永久保存，只有在所有订阅者都确认后才会删除。如果你想存储已经被消费者确认的消息，你需要配置[消息保留策略](#消息保留策略)。

对于一个批处理消息，如果启用了批索引确认，broker 会保持批索引的确认状态，并跟踪每个批索引的确认状态，以避免将确认的消息调度给消费者。该批消息的所有索引都被确认后，该批消息将被删除。

消息被逐一确认或批量确认。在批量确认的情况下，消费者只需要确认它收到的最后一条消息。流里的所有消息（以及之前提供过的消息）都不会被再次发送给那个消费者。

消息确认可采用以下两种方式：

- 单个确认消息。在单个确认的情况下，消费者需要确认单个消息，并向 broker 发送确认请求。
- 批量确认消息。在批量确认的情况下，消费者只要确认收到的最后一条消息。流里的所有消息（以及之前提供过的消息）都不会被再次发送给那个消费者。

> **注**
> 
> 批量确认不能在[共享订阅模式](#shared)中使用，因为共享订阅模式涉及到多个消费者，他们可以访问同一个订阅。共享订阅模式的消息需要单个确认。

### 确认超时

如果消息没有被成功消费，而需要触发 broker 自动重新传递消息，可以采用未确认消息自动重新传递机制。客户端跟踪整个 `acktimeout` 时间范围内未确认消息，当确认超时时，自动向 broker 发送  `redeliver unacknowledged messages`  请求。

> **注**
> 
> - 如果启用了批处理，同一批次中的其他消息和未被确认的消息将被重新交付给消费者。
> - 相对于确认超时，优选取消确认。取消确认更精确地控制单个消息的再传递，在消息处理时间超过确认超时时，可避免发生无效再传递。

## 否定确认（negative acknowledgement）

当消费者某次没有成功地消费消息、并希望再次消费该消息时，消费者会向 broker 发送否定确认，然后 broker 就会重新传递该消息。

根据不同的消费订阅模式，可以单个或批量否定确认。

Exclusive 和灾备订阅模式中，消费者只对最后收到的消息进行否定确认。

在 shared 和 key_shared 订阅模式中，可以对消息进行单个否定确认。

需要注意的是，对有序订阅类型（如 Exclusive、灾备、Key_Shared 模式）进行否定确认，可能导致传输失败的消息到达消费者的顺序和原始顺序不同。 

> **注**
> 
> 如果弃用批处理，则同一批次中其他消息将连同否定确认的消息，一并重新传递给消费者。

## 订阅

订阅是一种命名的配置规则，决定了消息将被如何传递给消费者。在 Pulsar 中，有四种订阅模式可用：[Exclusive](#exclusive)、 [Shared](#shared)、[灾备](#failover)，和[Key_Shared](#key_shared)。 

### Exclusive

*Exclusive* 模式下，只允许一个消费者附加到该订阅。如果多个消费者使用同一个订阅来订阅同一个主题，就会发生错误。

如下图中，只允许**消费者A-0** 消费消息。

> Exclusive 模式为默认订阅模式。

![Exclusive subscriptions](../../image/pulsar-exclusive-subscriptions.png)

### 灾备

在*灾备*模式下，多个消费者可以附加到同一个订阅。为非分区主题或分区主题的每个分区挑选一个主消费者并接收消息。当主消费者断开连接时，所有（未确认和后续的）消息都被传递给排在主消费者随后的消费者。

对于分区的主题，broker 按照优先级和消费者名称的词汇顺序对消费者进行排序。然后，broker 将尝试将主题均匀地分配给具有最高优先级的消费者。

对于非分区主题，broker 按照消费者订阅非分区主题的顺序挑选消费者。

如下图所示，**消费者-B-0** 是主消费者，而**消费者-B-1** 紧跟在**消费者-B-0 **之后，因此在**消费者-B-0 **断开连接的情后，将成为下一个接受消息的消费者。

![Failover subscriptions](../../image/pulsar-failover-subscriptions.png)

### Shared

消息通过 round robin 轮询机制分发给不同的消费者，并且每个消息仅会被分发给一个消费者。 当消费者断开连接，所有已经发送给该消费者、但没有被确认的消息将被重新安排，分发给其它存活的消费者。

如下图所示，**消费者-C-1 **和**消费者-C-2 **能够订阅该主题，而**消费者-C-3** 和其他人同样也可订阅该主题。

> **Shared 模式的局限性**
> 
> 使用 Shared 模式时需要了解如下：
> * 不能保证消息的顺序。 
> * Shared 模式下不能使用批量确认。

![Shared subscriptions](../../image/pulsar-shared-subscriptions.png)

### Key_Shared

*Key_Shared*  模式下，多个消费者可以被加到同一个订阅中。消息被传递给多个消费者，有相同 key 的消息、或者相同预定 key 的消息将仅被传递给一个消费者。无论消息被重新交付多少次，它都只能交付给同一个消费者。当一个消费者连接或断开连接时，将导致接受服务的消费者针对 key 作出改变。

> **Key_Shared 模式的局限性**
> 当使用 Key_Shared  模式时需了解如下：
>
> * 需要为消息指定 key 或  `orderingKey` 。
> * Key_Shared 模式下不能使用批量确认。
> * 生产者应当禁用批处理，或使用基于key 批处理生成器。

![Key_Shared subscriptions](../../image/pulsar-key-shared-subscriptions.png)

## 多主题订阅

消费者订阅一个 Pulsar 主题时，默认情况下是订阅一个特定主题，例如 `persistent://public/default/my-topic`。Pulsar 消费者也可同时订阅多个主题。可以通过两种方式定义主题列表。

* 基于 [**regular expression**](https://en.wikipedia.org/wiki/Regular_expression)（regex），例如：`persistent://public/default/finance-.*`
* 通过明确指定的主题列表。

> **注**
> 
> 当通过 regex 订阅多个主题时，所有的主题必须是在同一个[命名空间](#命名空间)。 

订阅多个主题时，Pulsar 客户端会自动调用 API 来发现符合 regex 模式/列表的主题，然后订阅所有这些主题。如果暂时不存在主题，则一旦创建相关主题，消费者就会自动订阅它们。

> **订阅多个主题无法保证顺序**
>
> 当生产者向一个主题发送消息时，所有的消息都能确保以相同顺序从该主题读取。但在存在多个主题时却无法保证这样的顺序。当生产者向多个主题发送消息时，不能保证从这些主题中读取消息的顺序都相同。 
>

## 无消费者的订阅及其相应的模式 

当订阅没有消费者时，它的订阅模式是未定义的。当消费者连接到订阅时，才对订阅模式进行定义，并且可以通过用不同配置重新启动所有消费者来改变模式。
