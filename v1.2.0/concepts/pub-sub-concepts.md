---
title: 发布/订阅
id: pub-sub-concepts
category: concepts
---

Pulsar 基于[发布-订阅](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)模式（通常缩写为 pub-sub）。在这种模式中，[生产者](#生产者)向[主题](#主题)发布消息。[消费者](#消费者)[订阅](#订阅)这些主题，处理收到的消息，并在处理完成后发送确认。

创建订阅后，Pulsar 会保留所有消息，即使消费者已经断开连接，这些消息仍会保留。只有在消费者确认消息成功处理后，才会将消息丢弃。

# 租户

Pulsar 从诞生开始就是按照多租户系统设计的。为支持多租户，Pulsar 引入了“租户”概念。租户可以分布在多个集群中，并且每个租户都具有自己的身份验证和授权方案。也可以将租户作为管理单元，进行存储配额、消息  TTL 和隔离策略的管理。

如需了解关于创建租户的细节，参见[使用租户](/user-guides/admin/work-with-tenants.md)。

# 命名空间

命名空间是租户内的管理单元。在命名空间所设置的配置策略适用于在该命名空间中创建的所有主题。你可以使用 StreamNative 控制台、REST API 或 pulsar-admin CLI（命令行工具）为租户创建多个命名空间。

如需了解关于创建命名空间的细节，参见[使用命名空间](/user-guides/admin/work-with-namespaces.md)。

## 权限

Pulsar 在命名空间级别（租户和集群内）对权限进行管理。可以为特定的用户授予操作权限，如`消费`和`生产`。此外也可以撤销特定用户的权限。撤销后，这些用户将不能访问指定的命名空间。

## Backlog quota

Backlog 是指由 bookie 储存的、关于某一主题的未确认消息的集合。在未确认消息被处理和确认前，Pulsar 都会将这些消息储存在 backlog 中。
可以使用 backlog quota 控制在命名空间级别可以使用的 backlog 大小。对于 backlog quota，可设置的项目如下：

- 命名空间中，每个主题可允许的阈值大小
- 保留策略：决定了当超过阈值时 broker 的动作

下表列出了可用的保留策略。
| 策略 | 动作 |
| --- | --- |
| `producer_request_hold` | Broker 暂停、但不保留生产者请求的有效载荷（payload）。 |
| `producer_exception` | Broker 从客户端断开，并抛出异常。 |
| `consumer_backlog_eviction` | Broker 开始从 backlog 丢弃积压消息。 |
## Bundle

为了进行分配，命名空间被分成多个 bundle，每个 bundle 包括命名空间整体哈希范围的一部分。Bundle 是属于同一命名空间的主题的虚拟组。一个命名空间 bundle 的范围在两个 32 位哈希值之间，例如从 0x00000000 到 0xffffffff。默认情况下，每个命名空间支持 4 个 bundle。

由于 bundle 中主题的负载可能会随着时间而改变，broker 可以将一个 bundle 拆分成两个 bundle。随后新的较小的 bundle 被重新分配给不同的 broker。默认情况下，新拆分出来的 bundle 会被立即分配给其他 broker，以平衡流量分布。

## 调度速率

调度速率指命名空间的主题每秒调度的消息数量。要限制调度速率，可调节每秒消息数（`msg-dispatch-rate`）或每秒消息字节数（`byte-dispatch-rate`）。调度速率的单位是秒，可用 `dispatch-rate-period` 配置。默认情况下，`msg-dispatch-rate` 和 `byte-dispatch-rate` 都设置为 -1，表明禁用限流。

# 主题

和其他发布-订阅系统一样，Pulsar 的主题是消息从生产者传递给消费者的有命名的通道。Pulsar 支持持久化和非持久化主题。默认情况下，如果不指定主题类型，就会创建一个持久化主题。对于持久化主题，所有的消息都持久地保存在磁盘上（如果没有独立的 broker，消息会持久地保存在多个磁盘上）。非持久性主题的数据不会保存在存储磁盘上。

主题名称是 URL 的形式，具体结构如下：

```http
{persistent|non-persistent}://tenant/namespace/topic
```

主题名称组成 | 描述 
:--------------------|:-----------
`persistent` / `non-persistent` | 标识主题类型。Pulsar 支持持久化和[非持久化](#非持久化主题)主题。默认情况下，如果不指定主题类型，就会创建一个持久化主题。对于持久化主题，所有的消息都持久地保存在磁盘上（如果没有独立的 broker，消息会持久地保存在多个磁盘上）。而非持久性主题的数据不会保存在存储磁盘上。 
`tenant`             | 实例中的主题租户。租户是 Pulsar 多租户的基本要素，可跨集群。 
`namespace`          | 主题的管理单元，将相关主题进行分组管理。关于主题的多数配置都是在[命名空间](#命名空间)级别进行的。每个租户可以有一个或多个命名空间。 
`topic`              | 主题名称结构中的最后一个部分。主题名称在 Pulsar 实例当中没有特殊含义。 

无需在 Pulsar 中特意地创建主题。如果客户端向尚不存在的主题写入消息、或者从不存在的主题接收消息，Pulsar 会在[主题名称](#主题)提供的命名空间下自动创建该主题。如果在客户端创建主题时没有指定租户或命名空间，那么该主题将在默认的租户和命名空间中创建。也可以在指定的租户和命名空间中创建一个主题，例如 `persistent://my-tenant/my-namespace/my-topic`。`persistent://my-tenant/my-namespace/my-topic`，表示 `my-topic` 主题是在 `my-tenant` 租户下的 `my-namespace` 命名空间中创建的。

## 非持久化主题

非持久化主题的消息从未在磁盘中保存，只存放在内存中。进行非持久化传递时，如果结束 Pulsar broker 或断开订阅者与主题的连接，非持久化主题的所有传递中的消息将丢失。在非持久化主题中，broker 会将消息立即发送给所有连接的订阅者，而不会在 BookKeeper 中保存。 

### 性能

非持久化消息通常比持久化消息速度更快，因为对非持久化消息来说，broker 不会持久化保存消息，一旦该消息被传递给连接的 broker，就会立即向生产者返回确认信息。因此对于生产者，非持久化主题的发布延迟相对较短。

## 分区主题

普通的主题仅仅是由单一 broker 支持，这限制了主题的最大通量。分区主题是特殊类型的主题，由多个 broker 处理，因此允许更大的通量。分区主题实际上是由 N 个内部主题实现的，其中 N 是分区的数量。当向一个分区主题发布消息时，每条消息都会被路由到多个 broker 中的一个 broker。Broker 间如何分配分区则是由 Pulsar 自动处理。

### 路由模式

发布到分区主题时，必须指定一个*路由模式*。路由模式决定了消息应该发布到哪个分区，也就是哪个内部主题。

模式     | 描述 
:--------|:------------
`RoundRobinPartition` | 如果没有指定 key，生产者将在所有分区中以轮询（round-robin）方式发布消息，以达到最大通量。需要注意的是，轮询（round-robin）不作用于每条单独的消息，而是将其批量延迟边界设置为相同，以确保批量的有效性。而如果在消息上指定了 key，分区生产者将对 key 进行哈希运算，并将消息分配到一个特定的分区。此模式为默认模式。 
`SinglePartition`     | 如果没有指定 key，生产者将随机挑选单一分区，将所有消息发布到这个分区。如果消息指定了 key，则分区生产者将对 key 进行哈希运算，将消息分配到特定分区。 
`CustomPartition`     | 执行自定义消息路由来确定特定消息的分区。 

### 顺序保证

消息的排序与路由模式和消息的 key 相关。通常用户会希望以按键分区（Per-key-partition）保证顺序。

如果消息上附有 key，无论是使用 `SinglePartition` 还是 `RoundRobinPartition` 模式，消息都将根据 [Hashing scheme](#hashing-scheme)，被分配到对应的分区。

 顺序保证          | 描述 | 路由模式和 key                                               
:------------------|:------------|:------------
按键分区（Per-key-partition）  | 具有相同 key 的消息将按顺序排列，并放置在相同的分区。 | 使用 `SinglePartition` 或 `RoundRobinPartition` 模式，且每个消息都有 key。 
生产者排序（Per-producer）       | 所有来自同一个生产者的消息将按顺序排列。                | 使用 `SinglePartition` 模式，且并未对每个消息都提供 key。 

### Hashing scheme

Hashing scheme 是一组标准哈希函数的枚举，用于为特定消息进行分区选择。

标准哈希函数有两种：`JavaStringHash` 和 `Murmur3_32Hash`。
对生产者来说，默认的哈希函数是 `JavaStringHash`。
注意：当生产者来自不同语言的客户端时，`JavaStringHash` 不起作用。这种情况建议使用 `Murmur3_32Hash`。

## 死信主题

使用死信主题，可以在消息没有被成功消费时，让消费者继续消费新的消息。在这个机制中，未能被消费的消息将被储存到一个独立的主题中，即死信主题。你可决定如何处理死信主题中的消息。

死信主题依赖消息重新分发。消息重新传递的原因可以是：[确认超时](#确认超时)或[否定确认（ negative acknowledgement）](#否定确认)。如果要对消息使用否定确认（negative acknowledgement），需确保在确认超时前进行否定确认（negative acknowledgement）。

> **注意**    
> 目前，死信主题在[共享（shared）](#共享shared)和[键共享（key_shared）](#键共享key_shared)订阅模式下为启用状态。

## 重试主题

对于很多线上业务系统来说，业务逻辑处理异常，会导致消息被重新消费。为了配置重新消费失败消息的延迟时间，可以配置生产者向业务主题和重试主题发送消息，并在消费者端启用自动重试。当在消费者端启用自动重试时，如果消息没有被消费，则会被保存在重试主题中，因此消费者在指定的延迟时间后，会自动消费重试主题中的失败消息。

## Schema

Pulsar 具有内置 schema registry，客户端能够为每个主题上传数据 schema。这些 schema 决定了哪些数据类型是对该主题有效的。Pulsar schema 使你能够在构建和处理消息时使用特定语言的数据类型，简单的如 `string` ，也有更复杂的特定应用类型。

# 消息

消息是 Pulsar 的基本单位。如下表格列出了消息的组成部分。 

组成部分 | 描述 
:---------|:-------
值/数据有效载荷 | 消息所携带的数据。尽管消息数据也可以符合数据 schema，但所有 Pulsar 消息都包含原始字节。 
Key | 可以选择用 key 来标记消息，对主题压缩等操作有帮助。          
属性 | 用户自定义属性的键值对（可选）。          
 生产者名            | 生产消息的生产者的名字。如果没有指定生产者的名字，则会使用默认名。 
序列 ID | 每条 Pulsar 消息都属于其主题的有序序列。消息的序列 ID 是它在该序列中的顺序。 
 发布时间            | 发布消息的时间戳，由生产者自动生成。 
 事件时间            | 应用程序附加在消息上的时间戳（可选）。例如，应用程序会在消息被处理时附加一个时间戳。如果没有对事件时间进行任何设置，其值为 `0`。 
TypedMessageBuilder | 用来构建消息。可以通过  `TypedMessageBuilder` 来设置消息属性，如消息的 key 和赋值等。 </br> 在设置 `TypedMessageBuilder` 时，需要将 key 设置为字符串。如果把 key 设置为其他类型，如 AVRO 对象，key 就会以字节形式发送，这样就很难把 AVRO 对象发回给消费者。 

## 消息压缩

在传递过程中，可对生产者发布的消息进行压缩。Pulsar 目前支持以下的压缩类型： 

* [LZ4](https://github.com/lz4/lz4)
* [ZLIB](https://zlib.net/)
* [ZSTD](https://facebook.github.io/zstd/)
* [SNAPPY](https://google.github.io/snappy/)

## 消息保留和过期

默认情况下，Pulsar broker 会立即删除所有已被消费者确认的消息，而所有未确认的消息则一直储存在消息 backlog 中。

消息的保留和过期都是在[命名空间](#命名空间)级别进行管理的。下图解释了消息保留和过期的情况。

![Message retention and expiry](../../image/retention-expiry.png)

### 消息保留 

消息保留使你能够存储已经被消费者确认的消息。在消息保留机制中（如上图顶部所示），保留策略适用于命名空间中的所有主题，决定了即使消息已经被确认，也会被持久地保存在 Pulsar 中。而不在保留策略范围内的已确认消息将被删除。如果没有保留策略，*所有*已确认的消息都会被删除。 

### 消息过期

消息过期是给未确认消息设置一个生存时间（TTL）。

通过设置消息过期（如上图底部所示），即使消息还没有被确认，也会因为超过了为命名空间设定的 TTL 而被删除（例如，TTL 设置为 5 分钟，但 10 分钟过去了消息仍未被确认）。 

## 消息去重

当消息在 Pulsar 中存在一次以上时，就会出现重复消息。消息去重是 Pulsar 的一项可选功能，用于避免不必要的消息重复，即每条消息只处理一次，即使该消息被接收了不止一次。消息去重是在命名空间级别或主题级别进行处理的。

下图解释了禁用和启用消息去重时的情况：

![Pulsar message deduplication](../../image/message-deduplication.png)

上图的上半部分是消息去重功能被禁用的场景。生产者在一个主题上发布了消息 1；该消息到达一个 Pulsar broker，并被存储到 BookKeeper。然后生产者再次发送消息 1（由于一些重试逻辑而反复发送），消息被 broker 收到并再次存储到 BookKeeper，从而产生了重复的消息。

上图的下半部分，生产者发布消息 1，broker 接收到该消息并进行存储，至此和第一种场景的情况相同。但当生产者试图再次发送该消息时，broker 知道已经接收过消息 1，便不会再次存储该消息。

### 生产者幂等 

另一种消息去重的方式是确保每条消息*只生产一次*，这种方法通常被称为**生产者幂等**。这种方式的缺点是，它将消息去重的工作推迟到应用程序端来进行。而在 Pulsar 中，这是由 broker 来处理，无需修改 Pulsar 客户端代码，而只需要改动一下管理配置。详情请见管理消息去重。

### 去重和有效一次（effectively-once）语义

消息去重使得 Pulsar 成为理想的消息系统，可与流处理引擎（SPE）及其他提供有效一次（effectively-once）处理语义的系统一起使用。不提供自动消息去重的系统需要 SPE 或其他系统保证消息去重，这意味着要实现严格的消息排序，需要应用程序端来承担消息去重的任务。而使用 Pulsar，要实现严格的顺序保证无需付出任何应用程序端的成本。

## 延迟消息传递

延迟消息传递使得消费者无需立即消费一条消息，而是可以稍后消费。在这个机制中，消息被存储在 BookKeeper 中，消息被发布给 broker 后，`DelayedDeliveryTracker` 在内存中维护时间索引（time->messageId），一旦超过特定的延迟时间，就会将消息发送给消费者。 

延迟消息发送只在[共享（shared）](#共享shared)订阅模式下有效。在[独占（exclusive）](#独占exclusive)和[灾备（failover）](#灾备failover)订阅模式下，延迟的消息仍会被立即发送。

下图解释了延迟消息传递的概念：

![Delayed Message Delivery](../../image/message_delay.png)

Broker 保存消息而不做任何检查。当消费者消费消息时，如果该消息被设置为延迟，那么该消息将被添加到 `DelayedDeliveryTracker`。订阅从 `DelayedDeliveryTracker` 中检查并获得超时消息。 

# 生产者

生产者连接主题，并将消息发布给 Pulsar broker。 

## 发送模式

生产者向 broker 发送消息，发送可以是同步的（sync） 也可以是异步的（async）。

| 模式       | 描述 |
|:-----------|-----------|
| 同步发送 | 生产者在发送每条消息后，都会等待来自 broker 的确认。如果没有收到确认，则生产者将认为发送失败。                                                                                                                     |
| 异步发送 | 生产者会将消息放到阻塞队列中并立即返回。客户端库在后台将消息发送给 broker。如果队列已满（用户可以配置队列大小），则调用 API 时，生产者可能会立即被阻止或失败，具体取决于传递给生产者的参数。 |

## 访问模式

对于生产者产生的主题，你可选择不同的访问模式。

| 访问模式           | 描述 |
|---|---|
|`共享（shared）`|多个生产者可在同一个主题发布消息。 <br><br>此为**默认**设置。|
|`独占（exclusive）`|仅一个生产者可在主题上发布消息。 <br><br>如果已经连接了一个生产者，则当其他生产者试图在这个主题上发布时，会立即出现错误。<br><br>如果原生产者和 broker 发生网络分区，则弃用原生产者，并选择一个新生产者作为下一个独占生产者。|
|`等待独占（WaitForExclusive）`|如果已经连接了一个生产者，那么这个生产者的创建将被挂起（而不是超时），直到这个生产者获得`独占（exclusive）`访问权限。<br><br>成功成为独占生产者后，这个生产者将被视为领导者。如果你想为应用程序实现领导者选举方案（leader election scheme），则可以使用这种访问模式。|

> **注意**
>
> 一旦某个应用程序出现一个生产者成功实现了`独占（exclusive）`或`等待独占（WaitForExclusive）`访问模式，该应用程序的实例将成为该主题的**唯一写入者**。其他生产者对这一主题进行消息生产时，将立即返回错误，或需要等待以获得`独占（exclusive）`访问权限。 

# 消费者

消费者通过订阅连接到主题，然后接收消息。

消费者向 broker 发送流许可请求以获得消息。在消费者端使用队列来接收从 broker 推送的消息。可以用 `receiverQueueSize` 参数来配置队列长度，默认值为 `1000`。每次调用 `consumer.receive()` 时，都会从缓冲区获取到一条消息。 

## 接收模式

从 broker 收到的消息可以是同步的（sync），也可以是异步的（async）。

| 模式     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| 同步接收 | 同步接收将保持阻塞，直到接收到消息。                         |
| 异步接收 | 异步接收会立即返回一个 future 值。例如 Java [`CompletableFuture`](http://www.baeldung.com/java-completablefuture)，一旦收到新消息就会完成。 |

## 确认

当消费者成功地消费消息，消费者会向 broker 发送确认请求。这个消息将被一直保存，直到所有订阅都确认后才会被删除。如果想要存储已经被消费者确认的消息，需要配置[消息保留策略](#消息保留和过期)。

对于一个批量消息，如果启用了批索引确认，broker 会保持批索引的确认状态，并跟踪每个批索引的确认状态，以避免将确认的消息发送给消费者。当该批量消息的所有索引都被确认后，该批量消息将被删除。

消息可以被逐一确认或累积确认。在批量确认的情况下，消费者只需要确认它收到的最后一条消息。所有之前（包含此条）的消息，都不会被再次发送给消费者。

消息确认可采用以下两种方式：

- 单独确认消息。在单独确认的情况下，消费者需要确认每条消息，并向 broker 发送确认请求。
- 累积确认消息。在累积确认的情况下，消费者只要确认收到的最后一条消息。所有之前（包含此条）的消息，都不会被再次发送给消费者。

> **注意**
> 
> 累积确认不能在 [共享（shared）订阅模式](#共享shared)中使用，因为共享（shared）订阅模式涉及到可以访问同一个订阅的多个消费者。共享（shared）订阅模式的消息需要单独确认。

### 确认超时

如果消息没有被成功消费，而需要让 broker 自动重新发送消息，可以使用未确认消息自动重新发送机制。客户端跟踪整个 `acktimeout` 时间范围内的未确认消息，当达到确认超时的设定时，自动向 broker 发送  `redeliver unacknowledged messages`  请求。

> **注意**
> 
> - 如果启用了批量，同一批次中的其他消息和未被确认的消息将被重新发送给消费者。
> - 相对于确认超时，建议优选否定确认（negative acknowledgement）。否定确认（negative acknowledgement）可以更精确地控制单个消息的重新分发，在消息处理时间超过确认超时的设定时，可避免发生无效的重新分发。

## 否定确认（negative acknowledgement）

当消费者某次没有成功地消费消息、并希望再次消费该消息时，消费者会向 broker 发送否定确认（negative acknowledgement），然后 broker 就会重新传递该消息。

根据不同的消费订阅模式，可以以单独或累积模式进行否定确认（negative acknowledgement）。

在独占（exclusive）和灾备（failover）订阅模式中，消费者只对最后收到的消息进行否定确认（negative acknowledgement）。

在共享（shared）和键共享（key_shared）订阅模式中，可以对消息进行单独否定确认（negative acknowledgement）。

需要注意的是，对有序订阅类型（如独占、共享、键共享模式）进行否定确认（negative acknowledgement），可能导致传递失败的消息到达消费者的顺序和原始顺序不同。 

> **注意**
> 
> 如果启用批量，则同一批次中其他消息将连同否定确认（negative acknowledgement）的消息，一并重新传递给消费者。

## 订阅

订阅是命名好的配置规则，决定了消息将被如何交付给消费者。在 Pulsar 中，有四种订阅模式可用：[独占（exclusive）](#独占exclusive)、 [共享（shared）](#共享shared)、[灾备（failover）](#灾备failover) 和[键共享（key_shared）](#键共享key_shared)。 

### 独占（exclusive）

*独占（exclusive）*模式只允许订阅中有一个消费者。如果多个消费者使用相同的订阅来订阅同一个主题，就会发生错误。

如下图中，只允许**消费者 A-0** 消费消息。

> 独占（exclusive）模式为默认订阅模式。

![Exclusive subscriptions](../../image/pulsar-exclusive-subscriptions.png)

### 灾备（failover）

在*灾备（failover）*模式下，多个消费者可以共同使用同一个订阅。系统会为非分区主题或每个分区主题选择一个主消费者并接收消息。当主消费者断开连接时，所有（未确认和后续的）消息都被发送给排在主消费者随后的消费者。

对于分区的主题，broker 按照优先级和消费者名称的词汇顺序对消费者进行排序。然后，broker 将尝试将主题均匀地分配给具有最高优先级的消费者。

对于非分区主题，broker 按照消费者订阅非分区主题的顺序选择消费者。

如下图所示，**消费者 B-0** 是主消费者，而**消费者 B-1** 是队列里紧跟着的消费者，因此在**消费者 B-0 **断开连接后，**消费者 B-1** 将成为下一个接受消息的消费者。

![Failover subscriptions](../../image/pulsar-failover-subscriptions.png)

### 共享（shared）

在*共享（shared）*或*轮询（round robin）*模式下，多个消费者可以附加到同一个订阅上。消息通过轮询（round robin）机制分发给不同的消费者，并且每条消息仅会被分发给一个消费者。当消费者断开连接，所有已经发送给该消费者的未确认消息将被重新分发给剩下的消费者。

如下图所示，**消费者 C-1 **和**消费者 C-2 **能够订阅该主题，而**消费者 C-3** 和其他消费者同样也可订阅该主题。

> **共享（shared）模式的局限性**
> 
> 使用共享（shared）模式时，需注意：
> * 消息的顺序是不能保证的。 
> * 共享（shared）模式下不能使用累积确认。

![Shared subscriptions](../../image/pulsar-shared-subscriptions.png)

### 键共享（key_shared）

在*键共享（key_shared）*模式下，多个消费者可以被加到同一个订阅中。消息被分发给多个消费者，有相同 key 的消息、或者有相同排序 key 的消息将只被交付给一个消费者。无论消息被重新传递多少次，它都只能交付给同一个消费者。当消费者进行连接或断开连接时，对于一些消息的 key，消费者将发生改变。

> **键共享（key_shared）模式的局限性**
> 使用键共享（key_shared）模式时，需注意：
>
> * 需要为消息指定 key 或  `orderingKey`。
> * 键共享（key_shared）模式下不能使用累积确认。
> * 生产者应当禁用批量，或使用基于 key 的批量生成器。

![Key_Shared subscriptions](../../image/pulsar-key-shared-subscriptions.png)

## 多主题订阅

当消费者订阅一个 Pulsar 主题时，默认情况下是订阅一个特定主题，例如 `persistent://public/default/my-topic`。但是，Pulsar 消费者也可同时订阅多个主题。可以通过以下两种方式来定义主题列表：

* 基于[**正则表达式**](https://en.wikipedia.org/wiki/Regular_expression)（regex），例如：`persistent://public/default/finance-.*`
* 定义一个包含明确主题的列表。

> **注意**
> 
> 当通过 regex 订阅多个主题时，所有的主题必须在同一个[命名空间](#命名空间)。 

订阅多个主题时，Pulsar 客户端会自动调用 API 来找到符合 regex 规则或自定义列表的主题，然后订阅这些主题。如果暂时不存在主题，则一旦创建相关主题，消费者就会自动订阅它们。

> **多主题无顺序保证**
>
> 当生产者向一个主题发送消息时，所有的消息都能确保以相同顺序从该主题读取。但在多主题的情况下，却无法保证这样的顺序。当生产者向多个主题发送消息时，无法保证从这些主题中读取消息的顺序都相同。 

## 无消费者订阅及对应模式 

当订阅没有消费者时，它的订阅模式是未定义的。只有当消费者连接到订阅时，才对订阅模式进行定义，并且可以通过用不同配置重新启动所有消费者来改变模式。

